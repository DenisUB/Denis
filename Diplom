!pip install osmnx networkx matplotlib pandas -q

import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
import hashlib
import pickle
from pathlib import Path
import warnings
import re
import pandas as pd
import traceback
from matplotlib.lines import Line2D
import matplotlib.patches as mpatches

warnings.filterwarnings('ignore')

# Конфигурация
DEFAULT_ROAD_PROFILES = {
    'motorway': {'lanes': 4, 'maxspeed': 110, 'category': 'I', 'capacity': 2000},
    'motorway_link': {'lanes': 2, 'maxspeed': 70, 'category': 'I', 'capacity': 1500},
    'trunk': {'lanes': 3, 'maxspeed': 90, 'category': 'I', 'capacity': 1800},
    'trunk_link': {'lanes': 2, 'maxspeed': 70, 'category': 'I', 'capacity': 1400},
    'primary': {'lanes': 2, 'maxspeed': 60, 'category': 'II', 'capacity': 1200},
    'primary_link': {'lanes': 1, 'maxspeed': 50, 'category': 'II', 'capacity': 1000},
    'secondary': {'lanes': 2, 'maxspeed': 50, 'category': 'II', 'capacity': 1000},
    'secondary_link': {'lanes': 1, 'maxspeed': 40, 'category': 'II', 'capacity': 800},
    'tertiary': {'lanes': 1, 'maxspeed': 40, 'category': 'III', 'capacity': 600},
    'tertiary_link': {'lanes': 1, 'maxspeed': 30, 'category': 'III', 'capacity': 500},
    'residential': {'lanes': 1, 'maxspeed': 20, 'category': 'IV', 'capacity': 300},
    'unclassified': {'lanes': 1, 'maxspeed': 30, 'category': 'III', 'capacity': 400},
    'living_street': {'lanes': 1, 'maxspeed': 10, 'category': 'IV', 'capacity': 200},
    'service': {'lanes': 1, 'maxspeed': 15, 'category': 'IV', 'capacity': 150},
}

CATEGORY_COLORS = {
    'I': '#FF0000',     # Красный
    'II': '#FF9900',    # Оранжевый
    'III': '#00AA00',   # Зеленый
    'IV': '#888888',    # Серый
    'unknown': '#CCCCCC'
}

TRAFFIC_LIGHT_STYLES = {
    1: {'color': '#00FF00', 'marker': 'o', 'size': 1200, 'outline_size': 1400},
    2: {'color': '#00FF00', 'marker': 's', 'size': 1300, 'outline_size': 1500},
    3: {'color': '#FFFF00', 'marker': '^', 'size': 1400, 'outline_size': 1600},
    4: {'color': '#FF0000', 'marker': 'd', 'size': 1500, 'outline_size': 1700},
    5: {'color': '#FF0000', 'marker': 'D', 'size': 1600, 'outline_size': 1800},
    6: {'color': '#FF0000', 'marker': '*', 'size': 1700, 'outline_size': 1900},
}

def parse_speed(speed_value):
    if speed_value is None:
        return None

    if isinstance(speed_value, list):
        if speed_value:
            speed_value = speed_value[0]
        else:
            return None

    if isinstance(speed_value, (int, float)):
        return float(speed_value)

    if isinstance(speed_value, str):
        try:
            return float(speed_value)
        except ValueError:
            match = re.search(r'(\d+(?:\.\d+)?)', str(speed_value))
            if match:
                speed = float(match.group(1))
                if 'mph' in speed_value.lower():
                    speed *= 1.60934
                return speed

    return None

def assign_road_attributes(G, road_profiles):
    for u, v, k, data in G.edges(keys=True, data=True):
        highway_type = data.get('highway', 'unclassified')
        if isinstance(highway_type, list):
            highway_type = highway_type[0] if highway_type else 'unclassified'

        profile = road_profiles.get(highway_type, road_profiles['unclassified'])

        lanes = data.get('lanes')
        if lanes is None or lanes == '':
            data['lanes'] = profile['lanes']
        elif isinstance(lanes, str):
            try:
                data['lanes'] = int(float(lanes))
            except (ValueError, TypeError):
                data['lanes'] = profile['lanes']

        speed = data.get('maxspeed')
        if speed is None or speed == '':
            data['maxspeed'] = profile['maxspeed']
        else:
            parsed_speed = parse_speed(speed)
            data['maxspeed'] = parsed_speed if parsed_speed else profile['maxspeed']

        data['road_category'] = profile['category']
        data['highway_type'] = highway_type
        data['capacity'] = profile['capacity']

        if 'length' in data:
            try:
                data['length'] = float(data['length'])
            except (ValueError, TypeError):
                data['length'] = 100.0

        if 'name' in data and data['name']:
            if isinstance(data['name'], list):
                data['name'] = data['name'][0]

    return G

def add_travel_time_weights(G):
    for u, v, k, data in G.edges(keys=True, data=True):
        length = data.get('length', 0)
        if isinstance(length, str):
            try:
                length = float(length)
            except ValueError:
                length = 0.0
        length = float(length)

        speed = data.get('maxspeed', 30)
        if isinstance(speed, str):
            parsed_speed = parse_speed(speed)
            speed = parsed_speed if parsed_speed else 30
        elif speed is None:
            speed = 30

        speed = float(speed)

        if length > 0 and speed > 0:
            travel_time = (length / 1000) / speed * 3600
            data['travel_time'] = travel_time

            category = data.get('road_category', 'III')
            weight_multipliers = {
                'I': 0.8, 'II': 1.0, 'III': 1.2, 'IV': 1.5, 'unknown': 1.0
            }
            weight = travel_time * weight_multipliers.get(category, 1.0)

            data['weight'] = weight
            data['impedance'] = travel_time * (1.0 + (4 - data.get('lanes', 1)) * 0.1)
        else:
            data['travel_time'] = 60
            data['weight'] = 60
            data['impedance'] = 60

def create_road_network_graph(place_name, include_traffic_lights=False):
    print(f"Загрузка данных OSM для: {place_name}...")

    ox.settings.timeout = 60
    ox.settings.log_console = False

    try:
        print("   Используем название места...")
        G = ox.graph_from_place(place_name, network_type='drive', simplify=True)
        print(f"   Успешно! Загружено {G.number_of_nodes()} узлов и {G.number_of_edges()} ребер")

        if include_traffic_lights:
            print("   Добавление светофоров...")
            _add_traffic_lights_based_on_topology(G)

    except Exception as e:
        print(f"   Ошибка при загрузке из OSM: {str(e)[:100]}...")
        print("   Создаем тестовый граф для демонстрации...")
        if include_traffic_lights:
            G = _create_test_graph_with_traffic_lights()
        else:
            G = _create_test_graph()

    G = assign_road_attributes(G, DEFAULT_ROAD_PROFILES)
    add_travel_time_weights(G)

    print(f"\n✓ Граф построен успешно!")
    print(f"  Узлов: {G.number_of_nodes()}")
    print(f"  Ребер: {G.number_of_edges()}")

    return G

def _add_traffic_lights_based_on_topology(G):
    print("   Добавление светофоров на основе топологии...")
    traffic_light_count = 0

    for node, data in G.nodes(data=True):
        street_count = data.get('street_count', 0)
        if street_count >= 3:
            if 'traffic_lights' not in data:
                data['traffic_lights'] = []

            phases = min(max(2, street_count - 1), 5)
            data['traffic_lights'].append({
                'id': f"tl_{node}",
                'lat': data.get('y', 0),
                'lon': data.get('x', 0),
                'type': 'traffic_signals',
                'phases': phases,
                'cycle_time': 60 + phases * 15
            })
            traffic_light_count += 1

    print(f"   Добавлено {traffic_light_count} светофоров")

def _create_test_graph_with_traffic_lights():
    G = nx.MultiDiGraph()

    test_nodes = [
        (1, {'y': 55.75, 'x': 37.50, 'street_count': 4,
             'traffic_lights': [{'id': 'tl_1', 'lat': 55.75, 'lon': 37.50, 'phases': 3}]}),
        (2, {'y': 55.75, 'x': 37.51, 'street_count': 3,
             'traffic_lights': [{'id': 'tl_2', 'lat': 55.75, 'lon': 37.51, 'phases': 2}]}),
        (3, {'y': 55.76, 'x': 37.50, 'street_count': 2, 'osmid': 1003}),
        (4, {'y': 55.76, 'x': 37.51, 'street_count': 4,
             'traffic_lights': [{'id': 'tl_4', 'lat': 55.76, 'lon': 37.51, 'phases': 4}]}),
    ]

    for node_id, attrs in test_nodes:
        G.add_node(node_id, **attrs)

    test_edges = [
        (1, 2, {'length': 850, 'highway': 'primary', 'name': 'Рублёвское шоссе'}),
        (2, 4, {'length': 1200, 'highway': 'secondary', 'name': 'ул. Крылатская'}),
        (4, 3, {'length': 900, 'highway': 'tertiary', 'name': 'ул. Маршала Тимошенко'}),
        (3, 1, {'length': 1100, 'highway': 'residential', 'name': 'Барвихинская ул.'}),
    ]

    for u, v, attrs in test_edges:
        G.add_edge(u, v, **attrs)

    print(f"   Создан тестовый граф со светофорами: {G.number_of_nodes()} узлов, {G.number_of_edges()} ребер")
    return G

def _create_test_graph():
    G = nx.MultiDiGraph()

    test_nodes = [
        (1, {'y': 55.75, 'x': 37.50, 'street_count': 4}),
        (2, {'y': 55.75, 'x': 37.51, 'street_count': 3}),
        (3, {'y': 55.76, 'x': 37.50, 'street_count': 2}),
        (4, {'y': 55.76, 'x': 37.51, 'street_count': 4}),
    ]

    for node_id, attrs in test_nodes:
        G.add_node(node_id, **attrs)

    test_edges = [
        (1, 2, {'length': 850, 'highway': 'primary', 'name': 'Рублёвское шоссе'}),
        (2, 4, {'length': 1200, 'highway': 'secondary', 'name': 'ул. Крылатская'}),
        (4, 3, {'length': 900, 'highway': 'tertiary', 'name': 'ул. Маршала Тимошенко'}),
        (3, 1, {'length': 1100, 'highway': 'residential', 'name': 'Барвихинская ул.'}),
    ]

    for u, v, attrs in test_edges:
        G.add_edge(u, v, **attrs)

    print(f"   Создан тестовый граф: {G.number_of_nodes()} узлов, {G.number_of_edges()} ребер")
    return G

def visualize_graph(G, save_path='road_network.png', show_traffic_lights=False):
    if G.number_of_nodes() == 0:
        print("Граф пустой, визуализация невозможна")
        return

    print(f"\nСоздание визуализации графа..." + (" со светофорами" if show_traffic_lights else ""))

    try:
        fig, ax = plt.subplots(figsize=(15, 12))

        for u, v, data in G.edges(data=True):
            category = data.get('road_category', 'unknown')
            color = CATEGORY_COLORS.get(category, '#CCCCCC')

            u_x, u_y = G.nodes[u].get('x', 0), G.nodes[u].get('y', 0)
            v_x, v_y = G.nodes[v].get('x', 0), G.nodes[v].get('y', 0)

            linewidth = 3.0
            if category == 'I': linewidth = 4.0
            elif category == 'II': linewidth = 3.5
            elif category == 'III': linewidth = 3.0
            else: linewidth = 2.5

            ax.plot([u_x, v_x], [u_y, v_y], color=color, linewidth=linewidth, alpha=0.8, zorder=1)

        if show_traffic_lights:
            print("   Рисуем светофоры...")
            traffic_light_data = _extract_traffic_lights(G)

            if traffic_light_data['x']:
                print(f"   Найдено {len(traffic_light_data['x'])} светофоров")

                phases_groups = {}
                for x, y, phases in zip(traffic_light_data['x'],
                                       traffic_light_data['y'],
                                       traffic_light_data['phases']):
                    if phases not in phases_groups:
                        phases_groups[phases] = {'x': [], 'y': []}
                    phases_groups[phases]['x'].append(x)
                    phases_groups[phases]['y'].append(y)

                for phases, coords in phases_groups.items():
                    style = TRAFFIC_LIGHT_STYLES.get(phases, TRAFFIC_LIGHT_STYLES.get(3))
                    if not style: continue

                    ax.scatter(coords['x'], coords['y'],
                              color='black', s=style['outline_size'],
                              marker=style['marker'], alpha=0.9, zorder=5)

                    ax.scatter(coords['x'], coords['y'],
                              color=style['color'], s=style['size'],
                              marker=style['marker'], alpha=1.0, zorder=6,
                              edgecolors='white', linewidth=3)

                    for x, y in zip(coords['x'], coords['y']):
                        ax.text(x, y, f"{phases}", fontsize=18,
                               ha='center', va='center', fontweight='bold',
                               color='black', zorder=7,
                               bbox=dict(boxstyle='circle,pad=0.3',
                                        facecolor='white', alpha=0.8,
                                        edgecolor='black', linewidth=2))

        _format_plot(ax, G, show_traffic_lights)
        _add_legend(ax, show_traffic_lights)

        plt.tight_layout()
        plt.savefig(save_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()

        print(f"✓ Визуализация сохранена в файл: {save_path}")

    except Exception as e:
        print(f"✗ Ошибка при визуализации: {str(e)[:100]}...")
        traceback.print_exc()

def _extract_traffic_lights(G):
    tl_x, tl_y, tl_phases = [], [], []

    for node, data in G.nodes(data=True):
        if 'traffic_lights' in data and data['traffic_lights']:
            for tl in data['traffic_lights']:
                lat = tl.get('lat', data.get('y', 0))
                lon = tl.get('lon', data.get('x', 0))

                if lat != 0 and lon != 0:
                    tl_x.append(lon)
                    tl_y.append(lat)
                    tl_phases.append(tl.get('phases', 3))

    return {'x': tl_x, 'y': tl_y, 'phases': tl_phases}

def _format_plot(ax, G, show_traffic_lights=False):
    title = "ДОРОЖНАЯ СЕТЬ РАЙОНА РУБЛЁВСКОГО ШОССЕ"
    if show_traffic_lights:
        title += f"\nСветофоры показаны цветными фигурами с номерами фаз"

    ax.set_title(title, fontsize=18, fontweight='bold', pad=20)
    ax.set_xlabel("Долгота (координата X)", fontsize=14)
    ax.set_ylabel("Широта (координата Y)", fontsize=14)
    ax.grid(True, alpha=0.2, linestyle='--', linewidth=0.5)
    ax.set_facecolor('#f5f5f5')

def _add_legend(ax, show_traffic_lights=False):
    legend_patches = []

    for category, color in CATEGORY_COLORS.items():
        if category != 'unknown':
            patch = mpatches.Patch(color=color, label=f'Категория {category}', alpha=0.8)
            legend_patches.append(patch)

    if show_traffic_lights:
        legend_patches.extend([
            Line2D([0], [0], marker='o', color='w', markerfacecolor='#00FF00',
                  markersize=15, label='1-2 фазы', markeredgecolor='black', markeredgewidth=2),
            Line2D([0], [0], marker='^', color='w', markerfacecolor='#FFFF00',
                  markersize=15, label='3 фазы', markeredgecolor='black', markeredgewidth=2),
            Line2D([0], [0], marker='d', color='w', markerfacecolor='#FF0000',
                  markersize=15, label='4+ фазы', markeredgecolor='black', markeredgewidth=2),
        ])

    legend_patches.append(Line2D([0], [0], marker='o', color='w',
                                markerfacecolor='darkblue', markersize=10,
                                label='Перекрестки', markeredgecolor='white'))

    ncol = 2 if show_traffic_lights else 1
    ax.legend(handles=legend_patches, loc='upper right', fontsize=12,
              framealpha=0.95, frameon=True, edgecolor='black', facecolor='white',
              bbox_to_anchor=(1.0, 1.0), ncol=ncol, title='Обозначения:')

def main():
    print("=" * 60)
    print("СИСТЕМА АНАЛИЗА ДОРОЖНОЙ СЕТИ СО СВЕТОФОРАМИ")
    print("=" * 60)
    print("Адаптировано для Google Colab")
    print("=" * 60)

    print("\nВыберите режим работы:")
    print("1. Стандартный режим (без светофоров)")
    print("2. Режим со светофорами")
    print("3. Тест светофоров (тестовый граф)")

    try:
        choice = input("\nВведите номер режима (1-3): ").strip()

        if choice == "1":
            print("\n" + "=" * 60)
            print("СТАНДАРТНЫЙ РЕЖИМ (БЕЗ СВЕТОФОРОВ)")
            print("=" * 60)

            road_graph = create_road_network_graph('Рублёвское шоссе, Москва', include_traffic_lights=False)
            visualize_graph(road_graph, 'road_network_no_traffic_lights.png', show_traffic_lights=False)

        elif choice == "2":
            print("\n" + "=" * 60)
            print("РЕЖИМ СО СВЕТОФОРАМИ")
            print("=" * 60)

            road_graph = create_road_network_graph('Рублёвское шоссе, Москва', include_traffic_lights=True)
            visualize_graph(road_graph, 'road_network_with_traffic_lights.png', show_traffic_lights=True)

        elif choice == "3":
            print("\n" + "=" * 60)
            print("ТЕСТ СВЕТОФОРОВ (ТЕСТОВЫЙ ГРАФ)")
            print("=" * 60)

            G = _create_test_graph_with_traffic_lights()
            visualize_graph(G, 'test_traffic_lights.png', show_traffic_lights=True)

        else:
            print("Неверный выбор, запускаю тест...")
            G = _create_test_graph_with_traffic_lights()
            visualize_graph(G, 'test_traffic_lights.png', show_traffic_lights=True)

        print("\n" + "=" * 60)
        print("✓ ВСЕ ОПЕРАЦИИ ЗАВЕРШЕНЫ!")
        print("=" * 60)

    except KeyboardInterrupt:
        print("\n\nПрограмма прервана пользователем.")
    except Exception as e:
        print(f"\n✗ ОШИБКА: {e}")
        traceback.print_exc()

# Запуск программы
if __name__ == "__main__":
    main()
